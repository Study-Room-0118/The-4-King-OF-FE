## 면접 Feedback

- 좀 더 STAR 방식으로 말하면 좋을 것 같다.
- 말을 너무 빠르게 하지말고 또박또박 말하자.
- 기획자, 디자이너도 쉽게 이해할 수 있도록 설명할 수 있게 하자

## 면접 질문

### 왜 Next.js의 Suspense는 fetch만 인식하고 axios등의 라이브러리는 인식하지 않는가?

- Next.js가 Suspense가 fetch를 인식할 수 있도록 최적화 해둔것이다.
- Next.js(app router,RSC) 데이터 요청을 추적, 캐시, 스트리밍 하기위해 런타임에 globalThis.fetch 를 계측한다.
즉, Next가 fetch를 살짝 래핑하여 아래 정보를 내부에 남긴다.

1. 요청 캐시/중복제거
2. 정적/동적 렌더링 판단
3. ISR, 온디맨드 revalidate/tag 연동
4. 서버 컴포넌트 스트리밍 경계와의 연결(Suspense Boudary)

반면 axios등의 임의 라이브러리는 위와같이 정보를 래핑해두지 않으므로, "지금 어떤 데이터가 대기중인지 프레임 워크가 모르기 때문에" 서스펜스 경게와 자동으로 연결되지 않음

"스트리밍/Suspense 연계”를 가능하게 하는 직접적인 정보는 → fetch가 반환하는 Promise이고,
Next는 이를 계측해서 “이 Promise가 어떤 컴포넌트 세그먼트와 연결되어 있는지” 메타데이터를 붙여 React 렌더러에게 넘겨준다

이를 통해 Next.js는 해당 Promise에 붙은 메타데이터를 통해 서버컴포넌트에서 어떤 fetch가 대기중인지 알 수 있고, 캐싱, 스트리밍, ISR, revalidate같은 기능이 작동한다.

#### 답변 다시써보기

>Next는 서버컴포넌트에서도 데이터 요청, 추적, 캐시, 스트리밍을 하기위해 런타임에서 globalThis.fetch를 가로채어 동작을 확인합니다.
즉 fetch를 살짝 래핑하여  호출 시점·옵션(예: cache, next.revalidate, next.tags)·캐시 키 등 메타데이터를 기록합니다.
>
>이 메타데이터 덕분에 서버 컴포넌트 렌더러는 “어느 세그먼트에서 어떤 fetch가 대기 중인지”와 “캐시 전략/리밸리데이트 규칙”을 알 수 있고, 그 결과로 동일 요청 dedupe, Data Cache 연동, ISR/온디맨드 무효화, 그리고 Suspense 경계를 통한 부분 스트리밍이 동작합니다.
>
>반면 axios는 Next가 계측하지 않는 일반 라이브러리이므로 이러한 메타데이터가 없고, Next의 캐시·ISR·스트리밍 파이프라인에 자동 편입되지 않습니다. React 차원에서 ‘Promise로서의 Suspense’는 걸리지만, Next.js 고유의 서버 사이드 최적화(정적/동적 판정, 태그 기반 revalidate)는 적용되지 않습니다.

>

### 모달창을 어떻게 관리했나? 모바일뷰에서의 창 고민을 해보았나?

#### 대화내용

- 모바일 뷰에선 쌓으면서 하는 동작이 많다보니 모달창의 우선순위를 정해서 레이어를 관리해야함
- react-portal 을 사용하면 모달의 우선순위를 관리할 수 있음, 안쓰고 퓨어하게 한다면 관리할 때 힘들 수 있음
- 루트에서 관리할 때 문제가 발생한다. 모달창 위에 모달창이 뜨기떄문에

(나는 모달창이 하나여서 해당경우가 아니였지만 레이어 관리를 어떻게 해야할지에 대해 생각해보자)

Portal(라이브러리 함수) : ReactApi DOM의 다른 위치로 컴포넌트를 순간이동시켜 렌더링 하는 기능, 단순히 위치만 옮겨주고, 항상 위에 떠야하는 UI에 사용

모달매니저: 애플리케이션 레벨에서 만든 상태/스택관리 조직, 모달이 여러개 동시에 열릴때 어떤게 위에있고, 스크롤 잠금은 언제하는지, 포커스는 어디로 가야하는지 등을 제어,

스태킹컨텍스트:브라우저는 DOM 요소를 페인팅 순서(그림 순서)에 따라 화면에 표시하는데 특정 속성(position, transform, opacity 등)이 적용된 요소는 자기만의 독립된 z-index 영역을 만든다. 그걸 스테킹 컨텍스트 라고한다.

즉, 같은 스태킹 컨텍스트 안에서는 z-index 값끼리 비교하지만, 다른 컨텍스트끼리는 “부모 컨텍스트”의 z-index 순서에 종속돼.

*보통 모달 매니저 내부에서 ReactPotal을 사용한다.
** 부모1의 컨텍스트 > 부모 2의 컨텍스트 라면
   부모 2의 자식이 부모 1의 자식보다 높은 높은 레이어이다.
*** 자식은 부모의 스태킹컨텍스트에서만 z-index로 경쟁한다.

#### 답변 다시 써보기

>우선 모달이 스테킹 컨텍스트의 영향을 받지 않도록 Portal을 이용하여 body 직하로 렌더링 합니다.
>
> 그리고 전역 z-index 토큰과 스택매니저로 다중 모달을 질서있게 관리합니다.

### SSE/WebSocket의 트레이드 오프

대화내용

- SSE와 WebSocket에 대해 좀 더 자세히 분석하고 트레이드 오프 분석
- 웹소켓을 버려야만 했던 이유는 ?
- sse와 비교해 어떤 장점이 있는지

비용
SSE: HTTP 커넥션 1개 헤더, KEEP-저렴
WebSocket: connection state + heartebeat -> 상대적으로 비용이 더 듬

#### 웹소켓을 버려야만 했던 이유

1. 양방향이 필요 없었습니다. 굳이 오버엔지니어링을 피하기위해 SSE를 사용했습니다.
2. WebSocket은 연결관리, 세션분산, reconnect등 추가구현이 많이 필요 하지만 SSE는 HTTP 스트리밍이므로 서버에서 res.write만으로 충분했고, 브라우저가 reconnect까지 처리해줘서 간단합니다.

따라서 양방향이 필요하지 않다면 굳이 웹소켓을 사용할 필요가 없었다.

***SSE가 끊기는 경우***
브라우저 표준 EventSource는 자동 재연결 기능이 있다.

서버에서 retry: 5000 헤더를 보내면, 끊겼을 때 5초 후 자동 재시도함

서버가 이벤트에 id:를 포함해주면, 재연결 시 Last-Event-ID 헤더로 이어받을 수 있음.
→ “메시지 중복/유실 방지가능”.

#### 답변 다시 써보기

> 실시간 통신에서 양방향 소켓(WebSocket)과 단방향 SSE(Server-Sent Events)는 트레이드오프가 있습니다. WebSocket은 양방향·바이너리 데이터 전송이 가능하지만, 연결 유지·heartbeat·스케일링 관리가 복잡하고 인프라 비용도 더 큽니다. SSE는 서버→클라
단방향이지만 HTTP 기반이라 더 안정적이고 자동 재연결·간단한 구현으로 알림, 로그, 스트리밍 같은 use case에 최적입니다.
>
> 저희는 클라이언트에서 보낼 메시지가 거의 없었기 때문에 WebSocket은 오버엔지니어링이었고, 방화벽·로드밸런서 제약도 있어 SSE로 전환했습니다. 비용 측면에서도 idle 상태에서 거의 0에 가까워 단순하고 안정적인 SSE를 사용했습니다.
