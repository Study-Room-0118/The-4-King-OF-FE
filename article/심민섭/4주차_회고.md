# 부족했던 개념들

## 디바운스 vs 스로틀

<details>
<summary>펼치기/접기</summary>

### 디바운스(Debounce)
- 이벤트가 연속해서 발생할 때, 마지막 이벤트 발생 후 일정 시간 동안 추가 이벤트가 없을 때에만 한 번 실행하는 기법
- 즉, 사용자가 특정 행동을 멈춘 후에야 실행
- 예) 검색창에서 타이핑할 때, 사용자가 입력을 멈추고 300ms 후에 검색 요청을 보내는 경우 
- 장점: 불필요한 반복 실행을 막아 서버 부하나 렌더링 부담을 줄여줌

예시 코드: 스크롤 멈춘 후 300ms 동안 추가 스크롤 없으면 새 데이터 불러옴
```typescript jsx
import React, { useState, useEffect } from "react";

function debounce(func: Function, delay: number) {
  let timer: NodeJS.Timeout;
  return (...args: any) => {
    clearTimeout(timer);
    timer = setTimeout(() => func(...args), delay);
  };
}

export function DebounceInfiniteScroll() {
  const [items, setItems] = useState<number[]>([]);
  
  const loadMore = () => {
    console.log("Load more items - debounce");
    // 추가 아이템 불러오기 로직
  };

  const handleScroll = debounce(() => {
    if (window.innerHeight + window.scrollY >= document.body.offsetHeight - 500) {
      loadMore();
    }
  }, 300);

  useEffect(() => {
    window.addEventListener("scroll", handleScroll);
    return () => window.removeEventListener("scroll", handleScroll);
  }, []);

  return <div>{/* 리스트 렌더링 */}</div>;
}
```

### 스로틀(Throttle)
- 이벤트가 계속해서 발생해도, 설정된 시간 간격마다 한 번씩만 실행하도록 제한하는 기법
- 연속 이벤트를 일정 주기로 나누어 실행
- 예) 스크롤 이벤트를 500ms에 한 번씩 처리하여 과도한 호출 방지
- 장점: 주기적으로 이벤트를 실행하므로 중간 중간 상태를 갱신할 수 있어 부드러운 사용자 경험을 제공

예시 코드: 스크롤이 계속되어도 500ms에 한 번 호출 제한하여 새 데이터 요청
```typescript jsx
import React, { useState, useEffect } from "react";

function throttle(func: Function, limit: number) {
  let inThrottle: boolean;
  return (...args: any) => {
    if (!inThrottle) {
      func(...args);
      inThrottle = true;
      setTimeout(() => (inThrottle = false), limit);
    }
  };
}

export function ThrottleInfiniteScroll() {
  const [items, setItems] = useState<number[]>([]);
  
  const loadMore = () => {
    console.log("Load more items - throttle");
    // 추가 아이템 불러오기 로직
  };

  const handleScroll = throttle(() => {
    if (window.innerHeight + window.scrollY >= document.body.offsetHeight - 500) {
      loadMore();
    }
  }, 500);

  useEffect(() => {
    window.addEventListener("scroll", handleScroll);
    return () => window.removeEventListener("scroll", handleScroll);
  }, []);

  return <div>{/* 리스트 렌더링 */}</div>;
}
```

### 디바운스가 입력창과 같은 이벤트에 더 유리함에도 무한 스크롤에서 고려되는 이유
사용자의 스크롤 이벤트가 매우 빠르고 빈번하게 발생할 때, 실제로는 마지막 스크롤 멈춤 시점에만 데이터를 새로 불러오는 것이 효율적일 수 있기 때문
- 스크롤이 멈추는 시점 감지
  - 사용자가 스크롤을 빠르게 내릴 때마다 데이터를 불러오면 과도한 네트워크 요청과 렌더링 부담이 발생
  - 디바운스는 "마지막 스크롤 후 일정 시간 동안 추가 스크롤이 없으면" 한 번만 처리하도록 해 과부하를 줄임
- 불필요한 요청 방지
  - 예를 들어, 사용자가 스크롤을 중간에 잠시 멈추면 그때 데이터를 요청해도 충분하다면 디바운스를 적용해 효율을 높일 수 있음
- 네트워크 비용 절감 및 UX 향상
  - 반복된 데이터 로드를 줄여 서버 부담을 낮추고, 사용자에게 부드러운 경험을 제공 

### 정리
```text
무한 스크롤에서는 주기적 상태 갱신(스로틀)과 마지막 이벤트 대기(디바운스)가 모두 상황에 따라 필요할 수 있습니다.
스로틀은 스크롤이 연속될 때 일정 주기로 상태를 업데이트하고, 
디바운스는 스크롤이 멈춘 시점에 한 번만 최종 데이터를 불러오는 데 사용됩니다.
```

[위로](#디바운스-vs-스로틀)

</details>

# 질문 다시 답변해보기

## 디바운스와 스로틀의 차이에 대해 말해주세요.

```text
디바운스와 스로틀은 이벤트가 반복적으로 발생할 때 불필요한 함수 호출과 네트워크 요청을 줄여 성능을 최적화하는 기법들입니다.

디바운스는 마지막 이벤트 발생 후 일정 시간 동안 이벤트가 없을 때에만 한 번 실행하는 기법으로,
주로 검색창에서 사용자 입력이 멈추고 일정 시간이 지난 후에 요청하는 경우에 사용합니다.

스로틀은 이벤트가 계속해서 발생해도 설정된 시간 간격마다 한 번씩만 실행하도록 제한하는 기법으로,
주로 무한 스크롤 구현과 같은 기능에서 이벤트를 일정 주기마다 한번씩 처리하여 과도한 호출을 방지하기 위한 경우에 사용됩니다.
```
