# 부족했던 개념들

## 클린 아키택쳐 (Clean Architecture)
<details>
<summary>펼치기/접기</summary>

### 기본 개념 (5살 아이에게 설명하듯이)
- 클린 아키텍처는 소프트웨어를 깨끗하고 튼튼하게 만드는 설계 방법

#### 블록 쌓기 놀이처럼 생각하기
```text
소프트웨어를 만드는 건 블록을 쌓는 놀이와 아주 비슷해. 
블록집을 지을 때 "창문 블록"과 "문 블록"이 따로 있듯, 컴퓨터 프로그램도 여러 가지 블록(기능)을 따로따로 만들어서 모으는 거야.
```

#### 안쪽과 바깥쪽의 약속
```text
블록집에서 벽돌이 서로 너무 꽉 붙으면, 문을 새로 달기 어렵지?
클린 아키텍처는 블록(기능)들이 서로 서로를 너무 많이 의지하지 않게 해서, 하나를 바꿔도 다른 것들은 멀쩡하게 남아있게 해줘.
```

#### 변화에 강한 집 만들기
```text
블록집에 창문이나 문을 바꾸고 싶을 때, 클린 아키텍처로 쌓은 집은 쉽게 고칠 수 있어. 
왜냐하면 각 블록(기능)이 자기 일만 딱 해놓고, 필요할 때만 살짝 연결되거든.
```

### 클린 아키텍처의 구조
![img_2.png](images/img_2.png)
1. 엔티티 / 도메인 계층
   - 비즈니스의 핵심 데이터와 불변하는 도메인 규칙을 캡슐화
   - 예시: 사용자를 나타내는 엔티티 클래스

```typescript
// entities/User.ts
export class User {
    constructor(public id: number, public name: string) {}
}
```

2. 유스케이스 (Use Case) 계층
   - 사용자가 실제로 서비스를 사용할 때 동작하는 업무 규칙을 담당
   - 엔티티를 활용해 비즈니스 프로세스를 수행하는 코드가 들어감
   - 예시: 사용자의 이름을 확인하는 유스케이스

```typescript
// usecases/GetUserName.ts
import { UserRepository } from "../domain/UserRepository";
import { User } from "../entities/User";

export class GetUserName {
    constructor(private userRepository: UserRepository) {}

    async execute(userId: number): Promise<string> {
        const user: User = await this.userRepository.getUserById(userId);
        return user.name;
    }
}
```

3. 인터페이스 어댑터 계층
   - 유스케이스와 외부 세계의 소통 창구 역할
   - 예를 들어 화면에 보여지는 데이터 형식으로 변환하거나, DB·API 등에서 데이터를 받아와 유스케이스가 쓸 수 있도록 제공
   - 예시: 사용자 정보를 DB에서 읽어 오기 위한 리포지토리

```typescript
// domain/UserRepository.ts (인터페이스 - 도메인 계층)
import { User } from "../entities/User";

export interface UserRepository {
    getUserById(userId: number): Promise<User>;
}
```

```typescript
// infrastructure/InMemoryUserRepository.ts (구현체 - 인프라 계층)
import { UserRepository } from "../domain/UserRepository";
import { User } from "../entities/User";

export class InMemoryUserRepository implements UserRepository {
    private users = [new User(1, "철수"), new User(2, "영희")];

    async getUserById(userId: number): Promise<User> {
        return this.users.find((user) => user.id === userId)!;
    }
}
```

4. 프레임워크/드라이버 계층
   - 프로그램이 동작하는 환경(웹 프레임워크, 데이터베이스, 서버 등)과 관련된 코드가 포함
   - 이 계층의 변경이 내부 핵심 로직에 영향을 주지 않도록 함
   - 예시: Spring, Express 등과 연결하는 코드, DB 드라이버 설정 등

```typescript
// components/UserName.tsx
import React, { useEffect, useState } from "react";
import { GetUserName } from "../usecases/GetUserName";
import { UserRepository } from "../domain/UserRepository";

interface Props {
    userId: number;
    userRepository: UserRepository; // 의존성 주입
}

export function UserNameComponent({ userId, userRepository }: Props) {
    const [name, setName] = useState<string>("");

    useEffect(() => {
        const getUserName = new GetUserName(userRepository);
        getUserName.execute(userId).then(setName);
    }, [userId, userRepository]);

    return <div>{name}</div>;
}
```

#### 예시 폴더 구조

```text
src/
  ├── entities/             # 엔티티 (핵심 비즈니스 데이터)
  │    └── User.ts
  ├── domain/               # 도메인 인터페이스 (비즈니스 규칙의 추상화)
  │    └── UserRepository.ts
  ├── usecases/             # 유스케이스 (애플리케이션 비즈니스 로직)
  │    └── GetUserName.ts
  ├── infrastructure/       # 인프라스트럭처 (외부 기술 구현체)
  │    └── InMemoryUserRepository.ts
  ├── adapters/             # 인터페이스 어댑터 (데이터 변환, 컨트롤러 등)
  │    └── UserController.ts
  ├── components/           # 프레임워크/드라이버 (UI, 웹 프레임워크)
  │    └── UserNameComponent.tsx
  └── index.ts              # 앱 엔트리포인트 (DI 컨테이너, 라우터 등)
```

#### 서비스 흐름 예시

1. 사용자 요청이 들어옴
   - 애플리케이션 엔트리포인트에서 DI 컨테이너가 의존성을 주입
2. 프레임워크/드라이버 계층
   - UserNameComponent가 props로 주입받은 UserRepository와 함께 렌더링
3. 유스케이스 계층 
   - UserNameComponent가 GetUserName 유스케이스를 생성하고 실행
4. 도메인 계층
   - GetUserName이 UserRepository 인터페이스를 통해 데이터 요청
5. 인프라스트럭처 계층
   - InMemoryUserRepository 구현체가 실제 데이터를 반환
6. 엔티티 계층
   - User 엔티티 객체에서 원하는 데이터(예: name) 추출
7. 결과 반환 및 UI 렌더링
   - GetUserName 유스케이스 결과를 받아 UserNameComponent가 화면에 보여줌

### 핵심 원칙: 의존성 규칙과 SOLID
의존성 규칙(Dependency Rule)은 코드의 방향이 안쪽(핵심 정책)을 향해야 하고, 바깥쪽(세부 사항)은 핵심을 몰라도 됨
- SRP(단일 책임 원칙): 하나의 책임만 가진다
- OCP(개방-폐쇄 원칙): 확장엔 열려 있고, 변경엔 닫혀 있다
- LSP(리스코프 치환 원칙): 상속이 올바르게 동작한다
- ISP(인터페이스 분리 원칙): 인터페이스는 작게, 필요한 것만 제공한다
- DIP(의존 역전 원칙): 추상(정책)에 의존하고, 세부적인건 늦게 결정해서 결합도 낮추기

### 클린 아키텍처의 가장 큰 장점은, <u>바깥쪽(외부 기술)이 바뀌더라도 핵심 로직은 변화 없이 유지</u>된다는 점

</details>

## FSD (Feature-Sliced Development)

<details>
<summary>펼치기/접기</summary>

### 대규모 프론트엔드 프로젝트에서 기능 단위로 프로젝트를 나누어 유지보수와 확장성 향상에 집중하는 개발론

### 계층 구조
1. 레이어 (Layer)
    - 프로젝트 최상위 디렉토리로, 기능과 역할별로 분리된 여러 레이어로 구성
    - 주요 레이어 종류:
        - app: 애플리케이션 초기화, 진입점 역할(라우터, 전역 설정 등)
        - pages: 페이지 단위 UI와 라우팅을 담당
        - widgets: 페이지에서 사용되는 독립적인 비즈니스 블록으로, 여러 features를 조합하여 만든 복합 UI 컴포넌트
        - features: 사용자 시나리오에 따른 비즈니스 기능 구현
        - entities: 비즈니스 핵심 개념(데이터 모델 등)
        - shared: 비즈니스 기능과 무관한 공통 컴포넌트, 유틸리티
```text
app (최상위)
↓
pages 
↓
widgets
↓  
features
↓
entities
↓
shared (최하위)
```
2. 슬라이스 (Slice)
    - 각 레이어 안에서 기능적 단위로 나눈 "슬라이스"가 있음
    - 하나의 슬라이스는 관련된 컴포넌트, 상태, API 호출 등을 포함하여 독립적으로 관리
3. 세그먼트 (Segment)
    - 슬라이스를 더욱 세분화한 단위로, 디렉터리 내 실제 코드 파일과 하위 폴더를 의미
    - 세밀한 관리와 모듈화를 위한 구조

### 핵심 원칙
- 기능 중심 설계: 애플리케이션을 비즈니스 기능 단위(Feature)로 나누어 개발
- 계층화: 각 기능은 레이어별로 구분되어 관심사가 분리
- 단방향 의존성: 상위 레이어가 하위 레이어에만 의존 가능하며, 하위 레이어는 상위에 의존하지 않음
- 명시적 공개 인터페이스: 각 모듈이나 기능은 명확한 공개 API를 통해서만 상호작용하도록 함
- 구성 가능성: 작은 기능 단위로 조합해 더 큰 기능을 만드는 식으로 개발
- 재사용과 독립성: 슬라이스 간 독립성을 추구하며, 재사용 가능한 컴포넌트는 shared 레이어에 둠

</details>

## CSS-in-JS

<details>
<summary>펼치기/접기</summary>

### 기본 개념 
- JavaScript 파일 내에서 CSS를 작성하는 방식
- styled-components, emotion 등이 대표적인 CSS-in-JS 라이브러리

### Zero-runtime이란
- CSS 스타일을 웹브라우저 런타임(실행 시간)에 동적으로 생성하거나 조작하지 않고, 애플리케이션 빌드 시점(컴파일 타임)에 미리 CSS 파일로 만들어서 제공하는 방식
- 스타일을 적용할 때 추가적인 JavaScript 코드 실행이 없으므로, 브라우저에 전달된 정적인 CSS 파일을 그대로 해석해 스타일을 적용

#### 주요 장점
- 스타일 생성 시기: 빌드 타임에 모든 CSS가 생성되고 추출되어 .css 파일로 분리
- 런타임 오버헤드 없음: 브라우저에서 스타일을 동적으로 생성하거나 수정하는 JavaScript 실행이 필요 없음
- 동적 스타일 제한: 빌드 시 정해진 스타일만 적용 가능하며, 런타임 동적 스타일은 CSS 변수(CSS custom properties) 등으로 제한적으로 처리
- 코드 최적화 효과: 필요없는 스타일이 포함되지 않아 번들 크기 감소와 빠른 렌더링 가능

### CSS-in-JS의 강점
1. 컴포넌트 단위 스타일 관리
   - 스타일과 컴포넌트가 한 파일에 있으므로 유지보수가 쉽고, 코드 간 결합도가 높아져 관리가 편리
2. 동적 스타일링 가능
   - JavaScript 변수와 조건문을 적용해 사용자별 동적 스타일을 쉽게 처리할 수 있음
3. 스타일 충돌 방지
   - 자동으로 네임스페이스가 분리되어 다른 컴포넌트 스타일과 충돌하지 않음
4. 사용하지 않는 스타일 제거
   - 라이브러리에 따라 미사용 스타일을 자동 정리해 코드 최적화가 가능

</details>

## 콜백과 프로미스

<details>
<summary>펼치기/접기</summary>

### 기본 개념

#### 콜백(Callback)
- 다른 함수의 인자로 전달되어 특정 이벤트가 발생하거나 작업이 완료되면 호출되는 함수
- 주로 비동기 작업의 결과를 처리하기 위해 사용됨
- 예를 들어, 서버에서 데이터를 받아서 그 결과를 콜백 함수 안에서 처리하는 방식

#### 프로미스(Promise)
- 비동기 작업의 성공(이행) 또는 실패(거부) 상태와 그 결과를 표현하는 객체
- .then(), .catch() 메서드를 사용해 결과를 처리하며, 체이닝(연속된 비동기 호출)을 쉽게 할 수 있음
- ES6 이후 공식적인 비동기 처리 메커니즘으로 자리 잡음

### 프로미스의 이점
- 가독성 향상: 복잡한 비동기 작업을 순차적으로 처리할 때 콜백 지옥 문제를 해결해줌
- 에러 처리 용이: .catch()를 통해 실패나 예외를 체계적으로 처리 가능
- 비동기 결과 재사용 가능: 프로미스 객체 자체에 결과를 저장하기 때문에 여러 곳에서 활용할 수 있음
- 코드 간결화: async/await 구문을 써서 마치 동기 코드처럼 비동기 작업을 처리할 수 있음

```javascript
// 콜백 지옥 예시
getData(function(a) {
    getMoreData(a, function(b) {
        getEvenMoreData(b, function(c) {
            // 깊어지는 중첩...
        });
    });
});

// 프로미스 체이닝
getData()
    .then(a => getMoreData(a))
    .then(b => getEvenMoreData(b))
    .then(c => console.log(c));
```


</details>

#  질문 다시 답변해보기

## 클린 아키택쳐의 핵심이 뭐라고 생각하시나요?

```text
클린 아키텍처의 핵심은 "의존성 규칙(Dependency Rule)"입니다.
이는 소스 코드의 의존성이 반드시 안쪽(고수준 정책)을 향해야 한다는 원칙으로,
외부 계층은 내부 계층을 알 수 있지만, 내부 계층은 외부 계층을 알아서는 안 됩니다.

이를 통해 비즈니스 규칙이 프레임워크, DB, UI에 독립적으로 시행될 수 있고, 변경에 대한 영향도가 최소화됩니다.

따라서 클린 아키텍처는 의존성의 방향을 제어함으로써 "관심사의 분리"와 "안정된 추상화"를 달성하는 것이 핵심입니다.
```

## 클린 아키택쳐와 비교했을 때, FSD 등과 같은 개발 방식에서 어떤 차이점이 있다고 느끼셨나요?

```text
클린 아키텍처는 시스템 내부 설계의 원칙과 경계 설정에 초점이 맞춰져 있고, 
FSD는 프론트엔드 기능 단위 조직과 협업을 위한 실용적인 코드 구조에 초점이 맞춰져 있다고 느꼈습니다. 

클린 아키택쳐를 통해 구현한 프로젝트의 경우,
Relay-GraphQL로부터 받은 데이터 활용이나 React 컴포넌트 구현을 클린 아키텍처의 바깥 계층에서 처리하고,
내부 핵심 로직에는 의존하지 않아 시스템이 견고하다는 인상을 받을 수 있었습니다.
또한 유스케이스 계층을 분리하면 핵심 비즈니스 로직에 대한 단위 테스트가 쉽고, UI 테스트와도 독립적으로 검증할 수 있는 점이 좋았던 것 같습니다.
단, 러닝 커브가 높았고, 핵심 비즈니스 규칙을 설정하는 기준과 계층에 따른 역할을 명확히 분리하는 것이 어려웠습니다.

반대로 FSD는 프론트엔드 프로젝트를 기능 단위로 나누고, 
그 기능별로 폴더와 코드를 명확히 분리해 개발자 간 협업과 확장성을 높이는 데 최적화되어 있어,
대규모 팀에서 병렬 개발이 가능하고 코드 소유권이 명확해져 개발이 좀 더 직관적이었던 것 같습니다.
```

## CSS-in-JS가 Zero-runtime 스타일과 비교했을 때, CSS-in-JS의 강점과 단점을 설명해주세요.

```text
개발 단계에서 CSS-in-JS를 사용함으로써 컴포넌트 단위로 스타일을 관리할 수 있던 점이 좋았습니다.
또한 Zero-runtime에서는 제한적이었던 동적 스타일링을 CSS-in-JS(런타임 방식)에서는 보다 직관적이고 쉽게 구현할 수 있었습니다.
그리고 자동으로 네임스페이스가 분리되어 다른 컴포넌트 스타일과 충돌하지 않는 점이 강점이라고 생각합니다.

반대로 컴포넌트와 스타일이 합쳐져 있기 때문에, 
단순히 스타일만 적용된 컴포넌트와 비즈니스 로직을 포함한 컴포넌트의 구분이 어려워 코드 가독성이 떨어지는 점이 단점이라고 생각했습니다.
클래스명 생성 방식이 동적 해시 기반이기 때문에 이름 생성이 난해하여 디버깅 시 html 구조를 참조하기는 어려웠습니다.
그리고 스타일 생성 및 주입 시 런타임 오버헤드가 있기 때문에 성능적인 측면에서는 항상 사용하기가 고민되는 부분인 것 같습니다.
```

## 콜백과 프로미스의 차이점에 대해서 설명해주시고, 프로미스가 더 나은 점이 있다면 설명해주세요.

```text
콜백 함수는 특정 이벤트가 발생하거나 작업이 완료되면 호출되는 함수로,
주로 비동기 작업의 결과를 처리하기 위해 사용됩니다.
예를 들어, 서버에서 데이터를 받아서 그 결과를 콜백 함수 안에서 처리하는 방식과 같습니다.

프로미스는 비동기 작업의 성공(이행) 또는 실패(거부) 상태와 그 결과를 표현하는 객체로,
.then(), .catch() 메서드를 사용해 결과를 처리하며, 체이닝(연속된 비동기 호출)을 쉽게 할 수 있습니다.

프로미스는 중첩된 콜백으로 인한 "콜백 지옥" 현상을 해결하여 가독성 측면에서 개선되었습니다.
또한, 프로미스 객체에 pending/fulfilled/rejected 상태로 비동기 작업의 진행 상황을 명확히 추적할 수 있고 저장된 결과를 여러 곳에서 재사용할 수 있습니다.
마지막으로 .catch()를 통해 모든 에러를 한 곳에서 통합적으로 처리할 수 있어 에러 관리가 훨씬 체계적이라고 생각합니다.
```