# 부족했던 개념들

## 클린 아키택쳐 (Clean Architecture)
<details>
<summary>펼치기/접기</summary>

### 기본 개념 (5살 아이에게 설명하듯이)
- 클린 아키텍처는 소프트웨어를 깨끗하고 튼튼하게 만드는 설계 방법

#### 블록 쌓기 놀이처럼 생각하기
```text
소프트웨어를 만드는 건 블록을 쌓는 놀이와 아주 비슷해. 
블록집을 지을 때 "창문 블록"과 "문 블록"이 따로 있듯, 컴퓨터 프로그램도 여러 가지 블록(기능)을 따로따로 만들어서 모으는 거야.
```

#### 안쪽과 바깥쪽의 약속
```text
블록집에서 벽돌이 서로 너무 꽉 붙으면, 문을 새로 달기 어렵지?
클린 아키텍처는 블록(기능)들이 서로 서로를 너무 많이 의지하지 않게 해서, 하나를 바꿔도 다른 것들은 멀쩡하게 남아있게 해줘.
```

#### 변화에 강한 집 만들기
```text
블록집에 창문이나 문을 바꾸고 싶을 때, 클린 아키텍처로 쌓은 집은 쉽게 고칠 수 있어. 
왜냐하면 각 블록(기능)이 자기 일만 딱 해놓고, 필요할 때만 살짝 연결되거든.
```

### 클린 아키텍처의 구조
![img_2.png](images/img_2.png)
1. 엔티티 / 도메인 계층
   - 비즈니스의 핵심 데이터와 불변하는 도메인 규칙을 캡슐화
   - 예시: 사용자를 나타내는 엔티티 클래스

```typescript
// entities/User.ts
export class User {
    constructor(public id: number, public name: string) {}
}
```

2. 유스케이스 (Use Case) 계층
   - 사용자가 실제로 서비스를 사용할 때 동작하는 업무 규칙을 담당
   - 엔티티를 활용해 비즈니스 프로세스를 수행하는 코드가 들어감
   - 예시: 사용자의 이름을 확인하는 유스케이스

```typescript
// usecases/GetUserName.ts
import { UserRepository } from "../domain/UserRepository";
import { User } from "../entities/User";

export class GetUserName {
    constructor(private userRepository: UserRepository) {}

    async execute(userId: number): Promise<string> {
        const user: User = await this.userRepository.getUserById(userId);
        return user.name;
    }
}
```

3. 인터페이스 어댑터 계층
   - 유스케이스와 외부 세계의 소통 창구 역할
   - 예를 들어 화면에 보여지는 데이터 형식으로 변환하거나, DB·API 등에서 데이터를 받아와 유스케이스가 쓸 수 있도록 제공
   - 예시: 사용자 정보를 DB에서 읽어 오기 위한 리포지토리

```typescript
// domain/UserRepository.ts (인터페이스 - 도메인 계층)
import { User } from "../entities/User";

export interface UserRepository {
    getUserById(userId: number): Promise<User>;
}
```

```typescript
// infrastructure/InMemoryUserRepository.ts (구현체 - 인프라 계층)
import { UserRepository } from "../domain/UserRepository";
import { User } from "../entities/User";

export class InMemoryUserRepository implements UserRepository {
    private users = [new User(1, "철수"), new User(2, "영희")];

    async getUserById(userId: number): Promise<User> {
        return this.users.find((user) => user.id === userId)!;
    }
}
```

4. 프레임워크/드라이버 계층
   - 프로그램이 동작하는 환경(웹 프레임워크, 데이터베이스, 서버 등)과 관련된 코드가 포함
   - 이 계층의 변경이 내부 핵심 로직에 영향을 주지 않도록 함
   - 예시: Spring, Express 등과 연결하는 코드, DB 드라이버 설정 등

```typescript
// components/UserName.tsx
import React, { useEffect, useState } from "react";
import { GetUserName } from "../usecases/GetUserName";
import { UserRepository } from "../domain/UserRepository";

interface Props {
    userId: number;
    userRepository: UserRepository; // 의존성 주입
}

export function UserNameComponent({ userId, userRepository }: Props) {
    const [name, setName] = useState<string>("");

    useEffect(() => {
        const getUserName = new GetUserName(userRepository);
        getUserName.execute(userId).then(setName);
    }, [userId, userRepository]);

    return <div>{name}</div>;
}
```

#### 예시 폴더 구조

```text
src/
  ├── entities/             # 엔티티 (핵심 비즈니스 데이터)
  │    └── User.ts
  ├── domain/               # 도메인 인터페이스 (비즈니스 규칙의 추상화)
  │    └── UserRepository.ts
  ├── usecases/             # 유스케이스 (애플리케이션 비즈니스 로직)
  │    └── GetUserName.ts
  ├── infrastructure/       # 인프라스트럭처 (외부 기술 구현체)
  │    └── InMemoryUserRepository.ts
  ├── adapters/             # 인터페이스 어댑터 (데이터 변환, 컨트롤러 등)
  │    └── UserController.ts
  ├── components/           # 프레임워크/드라이버 (UI, 웹 프레임워크)
  │    └── UserNameComponent.tsx
  └── index.ts              # 앱 엔트리포인트 (DI 컨테이너, 라우터 등)
```

#### 서비스 흐름 예시

1. 사용자 요청이 들어옴
   - 애플리케이션 엔트리포인트에서 DI 컨테이너가 의존성을 주입
2. 프레임워크/드라이버 계층
   - UserNameComponent가 props로 주입받은 UserRepository와 함께 렌더링
3. 유스케이스 계층 
   - UserNameComponent가 GetUserName 유스케이스를 생성하고 실행
4. 도메인 계층
   - GetUserName이 UserRepository 인터페이스를 통해 데이터 요청
5. 인프라스트럭처 계층
   - InMemoryUserRepository 구현체가 실제 데이터를 반환
6. 엔티티 계층
   - User 엔티티 객체에서 원하는 데이터(예: name) 추출
7. 결과 반환 및 UI 렌더링
   - GetUserName 유스케이스 결과를 받아 UserNameComponent가 화면에 보여줌

### 핵심 원칙: 의존성 규칙과 SOLID
의존성 규칙(Dependency Rule)은 코드의 방향이 안쪽(핵심 정책)을 향해야 하고, 바깥쪽(세부 사항)은 핵심을 몰라도 됨
- SRP(단일 책임 원칙): 하나의 책임만 가진다
- OCP(개방-폐쇄 원칙): 확장엔 열려 있고, 변경엔 닫혀 있다
- LSP(리스코프 치환 원칙): 상속이 올바르게 동작한다
- ISP(인터페이스 분리 원칙): 인터페이스는 작게, 필요한 것만 제공한다
- DIP(의존 역전 원칙): 추상(정책)에 의존하고, 세부적인건 늦게 결정해서 결합도 낮추기

### 클린 아키텍처의 가장 큰 장점은, <u>바깥쪽(외부 기술)이 바뀌더라도 핵심 로직은 변화 없이 유지</u>된다는 점

</details>

## FSD (Feature-Sliced Development)

<details>
<summary>펼치기/접기</summary>

### 대규모 프론트엔드 프로젝트에서 기능 단위로 프로젝트를 나누어 유지보수와 확장성 향상에 집중하는 개발론

### 계층 구조
1. 레이어 (Layer)
    - 프로젝트 최상위 디렉토리로, 기능과 역할별로 분리된 여러 레이어로 구성
    - 주요 레이어 종류:
        - app: 애플리케이션 초기화, 진입점 역할(라우터, 전역 설정 등)
        - pages: 페이지 단위 UI와 라우팅을 담당
        - widgets: 여러 페이지에서 재사용되는 독립 UI 컴포넌트
        - features: 사용자 시나리오에 따른 비즈니스 기능 구현
        - entities: 비즈니스 핵심 개념(데이터 모델 등)
        - shared: 비즈니스 기능과 무관한 공통 컴포넌트, 유틸리티
```text
app (최상위)
↓
pages 
↓
widgets
↓  
features
↓
entities
↓
shared (최하위)
```
2. 슬라이스 (Slice)
    - 각 레이어 안에서 기능적 단위로 나눈 "슬라이스"가 있음
    - 하나의 슬라이스는 관련된 컴포넌트, 상태, API 호출 등을 포함하여 독립적으로 관리
3. 세그먼트 (Segment)
    - 슬라이스를 더욱 세분화한 단위로, 디렉터리 내 실제 코드 파일과 하위 폴더를 의미
    - 세밀한 관리와 모듈화를 위한 구조

### 핵심 원칙
- 기능 중심 설계: 애플리케이션을 비즈니스 기능 단위(Feature)로 나누어 개발
- 계층화: 각 기능은 레이어별로 구분되어 관심사가 분리
- 단방향 의존성: 상위 레이어가 하위 레이어에만 의존 가능하며, 하위 레이어는 상위에 의존하지 않음
- 명시적 공개 인터페이스: 각 모듈이나 기능은 명확한 공개 API를 통해서만 상호작용하도록 함
- 구성 가능성: 작은 기능 단위로 조합해 더 큰 기능을 만드는 식으로 개발
- 재사용과 독립성: 슬라이스 간 독립성을 추구하며, 재사용 가능한 컴포넌트는 shared 레이어에 둠

</details>

#  질문 다시 답변해보기

## 클린 아키택쳐의 핵심이 뭐라고 생각하시나요?

```text
클린 아키텍처의 핵심은 "의존성 규칙(Dependency Rule)"입니다.
이는 소스 코드의 의존성이 반드시 안쪽(고수준 정책)을 향해야 한다는 원칙으로,
외부 계층은 내부 계층을 알 수 있지만, 내부 계층은 외부 계층을 알아서는 안 됩니다.

이를 통해 비즈니스 규칙이 프레임워크, DB, UI에 독립적으로 시행될 수 있고, 변경에 대한 영향도가 최소화됩니다.

따라서 클린 아키텍처는 의존성의 방향을 제어함으로써 "관심사의 분리"와 "안정된 추상화"를 달성하는 것이 핵심입니다.
```

## 클린 아키택쳐와 비교했을 때, FSD 등과 같은 개발 방식에서 어떤 차이점이 있다고 느끼셨나요?

```text
클린 아키텍처는 시스템 내부 설계의 원칙과 경계 설정에 초점이 맞춰져 있고, 
FSD는 프론트엔드 기능 단위 조직과 협업을 위한 실용적인 코드 구조에 초점이 맞춰져 있다고 느꼈습니다. 

클린 아키택쳐를 통해 구현한 프로젝트의 경우,
Relay-GraphQL로부터 받은 데이터 활용이나 React 컴포넌트 구현을 클린 아키텍처의 바깥 계층에서 처리하고,
내부 핵심 로직에는 의존하지 않아 시스템이 견고하다는 인상을 받을 수 있었습니다.
또한 유스케이스 계층을 분리하면 핵심 비즈니스 로직에 대한 단위 테스트가 쉽고, UI 테스트와도 독립적으로 검증할 수 있는 점이 좋았던 것 같습니다.
단, 러닝 커브가 높았고, 핵심 비즈니스 규칙을 설정하는 기준과 계층에 따른 역할을 명확히 분리하는 것이 어려웠습니다.

반대로 FSD는 프론트엔드 프로젝트를 기능 단위로 나누고, 
그 기능별로 폴더와 코드를 명확히 분리해 개발자 간 협업과 확장성을 높이는 데 최적화 되어 있기 때문에,
개발이 좀 더 했던 것 같습니다.
```