# 부족했던 개념들

## 클린 아키택쳐 (Clean Architecture)

### 기본 개념 (5살 아이에게 설명하듯이)
- 클린 아키텍처는 소프트웨어를 깨끗하고 튼튼하게 만드는 설계 방법

#### 블록 쌓기 놀이처럼 생각하기
```text
소프트웨어를 만드는 건 블록을 쌓는 놀이와 아주 비슷해. 
블록집을 지을 때 "창문 블록"과 "문 블록"이 따로 있듯, 컴퓨터 프로그램도 여러 가지 블록(기능)을 따로따로 만들어서 모으는 거야.
```

#### 안쪽과 바깥쪽의 약속
```text
블록집에서 벽돌이 서로 너무 꽉 붙으면, 문을 새로 달기 어렵지?
클린 아키텍처는 블록(기능)들이 서로 서로를 너무 많이 의지하지 않게 해서, 하나를 바꿔도 다른 것들은 멀쩡하게 남아있게 해줘.
```

#### 변화에 강한 집 만들기
```text
블록집에 창문이나 문을 바꾸고 싶을 때, 클린 아키텍처로 쌓은 집은 쉽게 고칠 수 있어. 
왜냐하면 각 블록(기능)이 자기 일만 딱 해놓고, 필요할 때만 살짝 연결되거든.
```

### 클린 아키텍처의 구조
![img_2.png](images/img_2.png)
1. 엔티티 / 도메인 계층
   - 비즈니스의 핵심 데이터와 불변하는 도메인 규칙을 캡슐화
   - 예시: 사용자를 나타내는 엔티티 클래스

```typescript
// entities/User.ts
export class User {
    constructor(public id: number, public name: string) {}
}
```

2. 유스케이스 (Use Case) 계층
   - 사용자가 실제로 서비스를 사용할 때 동작하는 업무 규칙을 담당
   - 엔티티를 활용해 비즈니스 프로세스를 수행하는 코드가 들어감
   - 예시: 사용자의 이름을 확인하는 유스케이스

```typescript
// usecases/GetUserName.ts
import { UserRepository } from "../domain/UserRepository";
import { User } from "../entities/User";

export class GetUserName {
    constructor(private userRepository: UserRepository) {}

    async execute(userId: number): Promise<string> {
        const user: User = await this.userRepository.getUserById(userId);
        return user.name;
    }
}
```

3. 인터페이스 어댑터 계층
   - 유스케이스와 외부 세계의 소통 창구 역할
   - 예를 들어 화면에 보여지는 데이터 형식으로 변환하거나, DB·API 등에서 데이터를 받아와 유스케이스가 쓸 수 있도록 제공
   - 예시: 사용자 정보를 DB에서 읽어 오기 위한 리포지토리

```typescript
// domain/UserRepository.ts (인터페이스 - 도메인 계층)
import { User } from "../entities/User";

export interface UserRepository {
    getUserById(userId: number): Promise<User>;
}
```

```typescript
// infrastructure/InMemoryUserRepository.ts (구현체 - 인프라 계층)
import { UserRepository } from "../domain/UserRepository";
import { User } from "../entities/User";

export class InMemoryUserRepository implements UserRepository {
    private users = [new User(1, "철수"), new User(2, "영희")];

    async getUserById(userId: number): Promise<User> {
        return this.users.find((user) => user.id === userId)!;
    }
}
```

4. 프레임워크/드라이버 계층
   - 프로그램이 동작하는 환경(웹 프레임워크, 데이터베이스, 서버 등)과 관련된 코드가 포함
   - 이 계층의 변경이 내부 핵심 로직에 영향을 주지 않도록 함
   - 예시: Spring, Express 등과 연결하는 코드, DB 드라이버 설정 등

```typescript
// components/UserName.tsx
import React, { useEffect, useState } from "react";
import { GetUserName } from "../usecases/GetUserName";
import { UserRepository } from "../domain/UserRepository";

interface Props {
    userId: number;
    userRepository: UserRepository; // 의존성 주입
}

export function UserNameComponent({ userId, userRepository }: Props) {
    const [name, setName] = useState<string>("");

    useEffect(() => {
        const getUserName = new GetUserName(userRepository);
        getUserName.execute(userId).then(setName);
    }, [userId, userRepository]);

    return <div>{name}</div>;
}
```

#### 예시 폴더 구조

```text
src/
  ├── entities/             # 엔티티 (핵심 비즈니스 데이터)
  │    └── User.ts
  ├── domain/               # 도메인 인터페이스 (비즈니스 규칙의 추상화)
  │    └── UserRepository.ts
  ├── usecases/             # 유스케이스 (애플리케이션 비즈니스 로직)
  │    └── GetUserName.ts
  ├── infrastructure/       # 인프라스트럭처 (외부 기술 구현체)
  │    └── InMemoryUserRepository.ts
  ├── adapters/             # 인터페이스 어댑터 (데이터 변환, 컨트롤러 등)
  │    └── UserController.ts
  ├── components/           # 프레임워크/드라이버 (UI, 웹 프레임워크)
  │    └── UserNameComponent.tsx
  └── index.ts              # 앱 엔트리포인트 (DI 컨테이너, 라우터 등)
```

#### 서비스 흐름 예시

1. 사용자 요청이 들어옴
   - 애플리케이션 엔트리포인트에서 DI 컨테이너가 의존성을 주입
2. 프레임워크/드라이버 계층
   - UserNameComponent가 props로 주입받은 UserRepository와 함께 렌더링
3. 유스케이스 계층 
   - UserNameComponent가 GetUserName 유스케이스를 생성하고 실행
4. 도메인 계층
   - GetUserName이 UserRepository 인터페이스를 통해 데이터 요청
5. 인프라스트럭처 계층
   - InMemoryUserRepository 구현체가 실제 데이터를 반환
6. 엔티티 계층
   - User 엔티티 객체에서 원하는 데이터(예: name) 추출
7. 결과 반환 및 UI 렌더링
   - GetUserName 유스케이스 결과를 받아 UserNameComponent가 화면에 보여줌

### 핵심 원칙: 의존성 규칙과 SOLID
의존성 규칙(Dependency Rule)은 코드의 방향이 안쪽(핵심 정책)을 향해야 하고, 바깥쪽(세부 사항)은 핵심을 몰라도 됨
- SRP(단일 책임 원칙): 하나의 책임만 가진다
- OCP(개방-폐쇄 원칙): 확장엔 열려 있고, 변경엔 닫혀 있다
- LSP(리스코프 치환 원칙): 상속이 올바르게 동작한다
- ISP(인터페이스 분리 원칙): 인터페이스는 작게, 필요한 것만 제공한다
- DIP(의존 역전 원칙): 추상(정책)에 의존하고, 세부적인건 늦게 결정해서 결합도 낮추기

### 클린 아키텍처의 가장 큰 장점은, <u>바깥쪽(외부 기술)이 바뀌더라도 핵심 로직은 변화 없이 유지</u>된다는 점

#  질문 다시 답변해보기

## 클린 아키택쳐의 핵심이 뭐라고 생각하시나요?

```text
클린 아키텍처의 핵심은 "의존성 규칙(Dependency Rule)"입니다.
이는 소스 코드의 의존성이 반드시 안쪽(고수준 정책)을 향해야 한다는 원칙으로,
외부 계층은 내부 계층을 알 수 있지만, 내부 계층은 외부 계층을 알아서는 안 됩니다.

이를 통해 비즈니스 규칙이 프레임워크, DB, UI에 독립적으로 시행될 수 있고, 변경에 대한 영향도가 최소화됩니다.

따라서 클린 아키텍처는 의존성의 방향을 제어함으로써 "관심사의 분리"와 "안정된 추상화"를 달성하는 것이 핵심입니다.
```
