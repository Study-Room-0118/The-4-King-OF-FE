## useMutation 사용 및 동작 원리

### useMutation 개념

- 서버에 **데이터 변경 요청**(Create, Update, Delete 등)을 보낼 때 사용하는 React Query Hook
- `mutationFn`을 통해 비동기 요청을 수행하고, 요청 상태 및 결과를 관리
- `onMutate`, `onSuccess`, `onError`, `onSettled` 같은 **라이프사이클 훅**을 활용해 데이터 흐름 제어 가능

### useMutation 동작 순서

useMutation의 반환 값인 mutation 객체의 `mutate` 메서드를 이용해서 요청 함수를 호출할 수 있다. `mutation.mutate(variables)` 방식으로 호출했을 때 다음과 같은 방식으로 다음 순서로 동작한다.

1. **호출 시**

```tsx
mutation.mutate(variables, { onSuccess, onError, onSettled });
```

- 호출과 동시에 **상태**가 `isIdle → isLoading` 으로 변경된다.
- 호출 시 넘긴 콜백은 훅 레벨의 콜백과 함께 실행된다.

1. **실행 순서 (성공 / 실패 공통 흐름)**

2-1. onMutate(variables)

- `mutationFn` 실행 **직전**에 호출한다.
- 쿼리 요청 취소 (`queryClient.cancelQueries`), 이전 데이터 스냅샷 저장 (`getQueryData`), 낙관적 업데이트 (`setQueryData`) 같은 작업을 수행한다.
- 반환값은 `context`가 되어 후속 콜백(`onError`, `onSettled`)에 전달된다.

2-2. `mutationFn(variables)` 실행

- 실제 서버로 데이터 변경 요청 (`fetch`, `axios`, `GraphQL` 등)을 보낸다.
- 요청이 진행되는 동안 `isLoading: true` 유지된다.
- 요청이 비동기이므로 응답이 올 때까지 `onSuccess`/`onError`는 실행되지 않는다.
- `retry` 옵션이 설정되어 있으면 실패 시 재시도 동작 후 최종 결과를 반환

**3. 성공했을 경우**

- **onSuccess(data, variables, context)**
  - mutationFn 응답(`data`)을 받으면 호출된다.
  - 서버 응답 기반으로 UI/캐시 최종 동기화하는 작업이 이루어진다.
  - 필요 시 쿼리 무효화 (`invalidateQueries`)를 진행한다.
- **onSettled(data, null, variables, context)**
  - 성공/실패 상관없이 마지막에 호출되는 콜백
  - 공통 정리 작업(로딩 해제, 폼 리셋 등)을 진행한다.

**4. 실패했을 경우**

- **onError(error, variables, context)**
  - mutationFn에서 오류 발생 시 호출된다.
  - 낙관적 업데이트 롤백 (`setQueryData`로 context 복원)을 진행한다.
  - 에러 로그/토스트 표시를 통해 사용자에게 상황을 알려줄 수 있다.
- **onSettled(data, null, variables, context)**
  - 성공/실패 상관없이 마지막에 호출되는 콜백
  - 공통 정리 작업(로딩 해제, 폼 리셋 등)을 진행한다.

### 전체 다이어그램

```tsx
mutate()
  ↓
[isIdle → isLoading]
  ↓
onMutate(variables) → context
  ↓
mutationFn(variables)
   ├── 성공 → onSuccess(data, vars, ctx)
   │         ↓
   │       onSettled(data, null, vars, ctx) → [isSuccess]
   │
   └── 실패 → onError(error, vars, ctx)
             ↓
           onSettled(undefined, error, vars, ctx) → [isError]
```

### BalanceTalk에서 useMutation 활용법

### 낙관적 업데이트(optimistic update)

- 좋아요 추가/삭제, 북마크 추가/삭제, 댓글 수정과 같은 사용자 상호작용 속도가 중요한 기능에 `useMutation`을 활용한 낙관적 업데이트를 적용했다.
- 이를 통해 다음과 같은 효과를 얻을 수 있었다.
  - 서버 응답을 기다리지 않고 UI를 즉시 변경해 빠른 피드백을 제공했다.
  - 실패 시 context 기반 롤백으로 데이터 정합성 유지할 수 있도록 했다.
  - 좋아요, 북마크, 댓글 수정 등 핵심 상호작용에서 부드러운 경험 제공

```tsx
const addLike = useMutation({
  mutationFn: ({ _postId, _commentId }: { _postId: number; _commentId: number }) =>
    fetchAddLikeComment(_postId, _commentId),
  onMutate: () => {
    if (parentCommentId) {
      const prevReplies: Replies | undefined = queryClient.getQueryData([
        'posts',
        'comments',
        postId,
        parentCommentId,
        'replies',
      ]);

      const newReplies = prevReplies?.map((comment: Comment) => {
        return comment.id === commentId
          ? { ...comment, myLike: true, likesCount: comment.likesCount + 1 }
          : comment;
      });

      queryClient.setQueryData(
        ['posts', 'comments', postId, parentCommentId, 'replies'],
        newReplies
      );
      return { prevReplies };
    }
    const prevCommentsPagination: CommentsPagination | undefined = queryClient.getQueryData([
      'posts',
      'comments',
      postId,
      selectedPageNumber,
    ]);

    const newComments = prevCommentsPagination?.content.map((comment: Comment) => {
      return comment.id === commentId
        ? { ...comment, myLike: true, likesCount: comment.likesCount + 1 }
        : comment;
    });

    queryClient.setQueryData(['posts', 'comments', postId, selectedPageNumber], {
      ...prevCommentsPagination,
      content: newComments,
    });
    return { prevCommentsPagination };
  },
  onError: (error, id, context) => {
    if (parentCommentId) {
      queryClient.setQueryData(
        ['posts', 'comments', postId, parentCommentId, 'replies'],
        context?.prevReplies
      );
    } else {
      queryClient.setQueryData(
        ['posts', 'commnets', postId, selectedPageNumber],
        context?.prevCommentsPagination
      );
    }
  },
});
```

### 쿼리 무효화 전략(invalidateQueries)

- 또한, **회원 투표 기능**에서는 사용자의 투표 여부에 따라 UI가 달라지기 때문에 쿼리 무효화 전략을 적용
- 이를 통해 투표 완료 후, 서버에서 최신 투표 결과를 가져와 댓글 활성화, 투표 결과 확인 등 UI를 동기화하여투표 여부에 따라 달라지는 UI를 실시간으로 반영

```tsx
// 회원 투표
const { mutate: voteBalanceOptionByUserMutate } = useMutation({
  mutationFn: (data) => voteBalanceOption(postId, { ...data }),
  onSuccess: async () => {
    // 투표 후 관련 쿼리를 무효화하여 최신 데이터로 UI 갱신
    await queryClient.invalidateQueries({ queryKey: ['posts', postId] });
  },
});
```

### 면접 답변

```markdown
Q) 밸런스톡 프로젝트에서는 `useMutation`hook을 어떻게 사용하셨나요?

밸런스톡 프로젝트에서는 사용자 상호작용 속도가 중요한 기능들—좋아요 추가/삭제, 북마크 추가/삭제, 댓글 수정, 투표 등—에 React Query의 useMutation을 적극 활용했습니다.
구체적으로, 좋아요, 북마크, 댓글 수정과 같은 기능에는 낙관적 업데이트(Optimistic Update) 패턴을 적용했습니다.
즉, 서버 응답을 기다리지 않고 UI를 즉시 변경하고, 이전 상태를 context에 저장하여 요청 실패 시 안전하게 롤백할 수 있도록 구현했습니다.
이렇게 하면 사용자가 느끼는 인터랙션 속도를 크게 개선하면서도 데이터 정합성을 유지할 수 있었습니다.
반면, 투표 기능과 같이 사용자의 선택에 따라 UI가 크게 달라지는 경우에는 쿼리 무효화(invalidateQueries) 전략을 사용했습니다.
투표 완료 후 서버에서 최신 데이터를 가져와 댓글 활성화 여부나 투표 결과를 즉시 반영하도록 했습니다.
이를 통해 UI가 항상 서버 상태와 동기화되면서도 사용자가 투표 직후 즉각적인 피드백을 받을 수 있었습니다.
정리하면, 프로젝트 전반에서 useMutation을 낙관적 업데이트와 쿼리 무효화를 상황에 맞게 혼합 적용함으로써,
빠르고 부드러운 UX와 안정적인 데이터 관리를 동시에 달성했습니다.
```

## 디바운스(Debounce)와 쓰로틀(Throttle)

### **디바운스 개념**

- 연이어 발생한 이벤트를 하나의 그룹으로 묶어서 처리하는 방식
- 짧은 시간 동안 여러 번 발생하는 이벤트 중 마지막 이벤트만 실행
  - 불필요한 API 호출을 최소화하는데 사용
- 이벤트가 연속으로 발생하면 실행을 지연시키다가, 마지막 이벤트 후 일정 시간 동안 추가 이벤트가 없으면 실행
- 사용사례
  - **검색창 입력, 윈도우 리사이즈, 자동완성** 등에서 사용

### 디바운스 코드

```tsx
function debounce(fn: Function, delay: number) {
  let timer: NodeJS.Timeout;
  return function (...args: any) {
    clearTimeout(timer);
    timer = setTimeout(() => fn.apply(this, args), delay);
  };
}
```

### 쓰로틀 개념

- 이벤트를 일정 주기마다 발생하도록 하는 기술
- 일정 시간 간격마다 이벤트를 한 번씩만 실행
  - CPU 과부하 방지하는데 사용
- 이벤트가 연속적으로 발생해도 설정한 간격 안에서는 추가 실행이 불가하다.
- 사용 사례
  - 스크롤 이벤트에서 무한 스크롤 처리

### 쓰로틀 코드

```tsx
function throttle(fn: Function, limit: number) {
  let lastCall = 0;
  return function (...args: any) {
    const now = Date.now();
    if (now - lastCall >= limit) {
      lastCall = now;
      fn.apply(this, args);
    }
  };
}
```

### 디바운스와 쓰로틀 비교

| 구분        | 디바운스(Debounce)                     | 쓰로틀(Throttle)                       |
| ----------- | -------------------------------------- | -------------------------------------- |
| 실행 시점   | 마지막 이벤트 후 일정 시간 지나야 실행 | 최초 이벤트 발생 후 일정 시간마다 실행 |
| 이벤트 빈도 | 낮춤 (마지막만 처리)                   | 일정 간격 유지                         |
| 주로 사용   | 검색창 입력, 리사이즈, 자동완성        | 스크롤, 마우스 이동, 무한 스크롤       |
| 장점        | 불필요한 호출 최소화                   | 이벤트 과부하 방지, 주기적 처리        |

### 면접 답변

```markdown
Q) Debounce와 Throttle에 대해 설명해주세요.

Debounce와 Throttle은 이벤트 처리를 최적화하는 기법입니다. Debounce는 이벤트가 연속으로 발생할 때, 마지막 이벤트가 발생한 후 일정 시간 동안 추가 이벤트가 없을 때 한 번만 실행됩니다.
예를 들어, 검색창 자동완성이나 입력창에서 불필요한 API 호출을 줄일 때 사용합니다. Throttle은 이벤트가 연속으로 발생해도 일정 시간 간격마다 한 번씩만 실행되도록 제한합니다.
스크롤 이벤트나 마우스 이동처럼 빈번하게 발생하는 이벤트를 일정 주기로 처리할 때 유용합니다.
정리하면, Debounce는 마지막 이벤트 후 실행으로 최종 처리에 적합하고, Throttle은 일정 간격마다 실행으로 반복 이벤트 최적화에 적합합니다.
```

## Ludo에서의 무한스크롤 구현 방식

Ludo 프로젝트에서 스터디 카드 리스트를 무한스크롤 방식으로 구현함. 구현 방식을 순서대로 정리하면 다음과 같다.

### **1. 데이터 페칭**

- `useRecruitments` 훅에서 `useInfiniteQuery`를 사용하여 페이지 단위로 데이터를 가져옵니다.
- `getNextPageParam`을 통해 마지막 데이터의 `id`를 다음 페이지 요청에 활용하여 다음 페이지가 있는지 여부 판단한다.

```tsx
//src/Hooks/recruitments/useRecruitments.ts
import { FilterOptionParams } from '@/Types/study';
import { useInfiniteQuery } from '@tanstack/react-query';
import { RECRUITMENT } from '@/Constants/queryString';
import { getRecruitments } from '@/Apis/recruitment';

export const useRecruitments = ({
  filterOptions,
  count,
}: {
  last?: number;
  count: number;
  filterOptions: Pick<
    FilterOptionParams,
    'categoryId' | 'positionId' | 'progressMethod' | 'stackIds'
  >;
}) => {
  const { data, hasNextPage, fetchNextPage, isLoading } = useInfiniteQuery({
    queryKey: [...RECRUITMENT.RECRUITMENTS(filterOptions)],
    queryFn: ({ pageParam }) => getRecruitments(filterOptions, count, pageParam),
    getNextPageParam: (lastPage) => {
      const recruitments = lastPage?.data?.data?.recruitments;
      if (recruitments?.length !== count) return undefined;
      return recruitments[recruitments.length - 1].id;
    },
    initialPageParam: undefined,
  });
  return { data, hasNextPage, fetchNextPage, isLoading };
};
```

### **2. Intersection Observer API 적용**

- `RecruitmentCardList`에서 `observeRef`를 `Target` 요소에 연결
- `useIntersectionObservable` 커스텀 훅을 통해 `IntersectionObserver`를 등록
- 타겟 요소가 화면에 나타나면 `onIntersect` 콜백이 실행되어 `fetchNextPage()` 호출
- `data.pages`를 `useMemo`로 평탄화(flatMap)하여 페이지별 데이터를 하나의 배열로 합침(데이터 병합)
- 합쳐진 배열을 기반으로 RecruitmentCard를 렌더링

```tsx
const RecruitmentCardList = () => {
  const { categoryId, stackIds, positionId, progressMethodId } = useFilterOptionsStore();
  const progressMethod = getProgressMethod(progressMethodId);

  const observeRef = useRef<HTMLDivElement>(null);

  const { data, hasNextPage, fetchNextPage, isLoading } = useRecruitments({
    filterOptions: { categoryId, stackIds, positionId, progressMethod },
    count: INFINITE_RECRUITMENTS_COUMT_PER_PAGE,
  });

  const onIntersect: IntersectionObserverCallback = ([entry]) => {
    if (entry.isIntersecting) fetchNextPage();
  };
  useIntersectionObservable(observeRef, onIntersect, hasNextPage);

  const recruitmentsPages = useMemo(
    () => (data ? data.pages.flatMap(({ data }) => data.data) : []),
    [data]
  );

  return (
    <RecruitmentCardsWrapper>
      {isLoading ? (
        <SkeletonRecruitmentCardList count={21} />
      ) : recruitmentsPages?.length && recruitmentsPages[0]?.recruitments?.length ? (
        recruitmentsPages.map((recruitmentsPage) =>
          recruitmentsPage?.recruitments.map((recruitment: Recruitment) => (
            <li key={recruitment.id}>
              <RecruitmentCard key={recruitment.id} {...recruitment} />
            </li>
          ))
        )
      ) : (
        <NotFoundResult />
      )}

      <Target ref={observeRef} />
    </RecruitmentCardsWrapper>
  );
};
```

### **3. 로딩/빈 상태 처리**

- `isLoading`이면 Skeleton UI 렌더링
- 데이터가 없으면 `NotFoundResult` 렌더링

### Intersection Observer API란

- DOM 요소가 다른 요소나 뷰포트(viewport)와 교차(intersect)하는지 여부를 비동기적으로 관찰할 수 있는 브라우저 API
- 스크롤 이벤트를 직접 감지하지 않고도 요소의 노출 여부를 효율적으로 확인 가능
- 주요 특징
  - **비동기 처리**: 스크롤 이벤트처럼 연속적으로 발생하지 않고, 브라우저가 최적화하여 콜백 호출
  - **성능 최적화**: 많은 DOM 요소를 동시에 관찰해도 스크롤 이벤트 리스너보다 부담이 적음

### Debounce 또는 Throttle 사용 여부

- 코드상에서 Intersection Observer를 직접 사용하고 있으며, 스크롤 이벤트를 직접 listen하지 않는다.
- `IntersectionObserver` 자체가 브라우저 최적화된 방식으로 이벤트를 관찰하고 콜백을 호출하므로, 스크롤 이벤트에서처럼 높은 빈도의 이벤트를 제어하기 위해 debounce/throttle이 필요하지 않다.

### 면접 답변

```markdown
Q) Ludo에서 무한스크롤을 구현한 방식에 대해 설명해주세요.

Ludo 프로젝트에서는 게시글 목록에서 무한스크롤을 구현하기 위해 React Query의 `useInfiniteQuery`와 Intersection Observer API를 활용했습니다.
구체적으로, `useInfiniteQuery`를 사용해 페이지 단위로 데이터를 불러오고, `getNextPageParam`으로 다음 페이지의 시작점을 계산했습니다.
화면 하단에 `Target` 요소를 두고, 이를 Intersection Observer로 감지하여 화면에 나타나면 `fetchNextPage()`를 호출하도록 했습니다.
이 방식의 장점은, 스크롤 이벤트를 직접 listen하지 않아도 브라우저가 최적화된 방식으로 요소 노출을 감지하므로 성능 부담이 적고, 불필요한 API 호출을 최소화할 수 있다는 점입니다.
또한, 각 페이지 데이터를 `flatMap`으로 합쳐서 렌더링하고, 로딩 상태와 데이터 없음을 처리하는 UI도 함께 구현했습니다.
정리하면, Ludo 프로젝트의 무한스크롤은 Infinite Query + Intersection Observer 조합을 활용해 성능 최적화와 사용자 경험을 동시에 만족시키는 구조로 구현했습니다.
```

### 출처

- [useMutation 공식 문서](https://tanstack.com/query/v5/docs/framework/react/reference/useMutation)
- [자스민의 디바운싱과 쓰로틀링](https://ysiksik.github.io/elegant-tekotok/2023-04-08-JASMINE-Debouncing-Throttling/)
- [react-query-tutorial](https://github.com/ssi02014/react-query-tutorial?tab=readme-ov-file#usemutation)
