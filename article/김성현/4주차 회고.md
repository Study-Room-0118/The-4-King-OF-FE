## 📓 Git과 Github

- Git은 코드 이력을 관리하는 도구
- GitHub는 Git을 기반으로 협업과 자동화를 지원하는 플랫폼

### Git

- Git은 분산 버전 관리 시스템(DVCS, Distributed Version Control System)입니다.
- 코드의 변경 이력을 로컬 저장소에 기록하고, 브랜치를 생성·병합하며, 협업 시 충돌을 해결하는 기능을 제공합니다.
- 주요 특징
  - 인터넷 연결 없이도 로컬에서 모든 버전 관리 가능
  - 브랜치를 활용한 독립적인 기능 개발 및 병합 가능
  - commit, merge, rebase 등의 강력한 이력 관리 도구 제공

### GitHub

- GitHub는 Git 저장소를 호스팅하고 협업을 지원하는 클라우드 기반 플랫폼입니다.
- 원격 저장소(remote repository)를 제공하여 팀원 간 코드 공유와 협업을 돕고, 이슈 트래킹·코드 리뷰·CI/CD 같은 부가 기능을 지원합니다.
- 주요 특징
  - 원격 저장소 제공 → git push, git pull로 팀 간 코드 동기화
  - Pull Request(PR)를 통한 코드 리뷰 및 협업 프로세스 지원
  - Actions를 통한 자동화 파이프라인(CI/CD) 구축 가능
  - 이슈, 프로젝트 보드 등 프로젝트 관리 도구 제공

## 📓 GitHub PR 병합 시, Merge Commit vs Squash Commit vs Rebase Commit

### Merge Commit

- 여러 커밋을 그대로 유지하면서 병합 브랜치에 새로운 병합 커밋을 생성하는 방식
- 동작 ex) main 브랜치로 PR을 병합할 때

  ```bash
    git merge feature-branch
  ```

  - main 브랜치에 "Merge pull request #123" 같은 병합 커밋이 생성됨.

- 장점

  - 브랜치 작업 내역을 그대로 유지하므로, 언제 어떤 작업이 있었는지 추적이 용이함.
  - 충돌이 발생해도 병합 커밋에서 한 번에 해결 가능.

- 단점

  - 브랜치가 많을 경우 커밋 그래프가 복잡해짐.
  - 작은 변경에도 불필요하게 병합 커밋이 늘어남.

- 추천 상황
  - 협업 프로젝트에서 작업 기록 추적이 중요한 경우
  - 릴리즈 브랜치 관리가 필요한 Git Flow 전략 사용 시

### Squash and Merge

- 모든 커밋을 1개의 커밋으로 합쳐서 병합
- 동작 ex) feature-branch의 여러 커밋을 하나로 합쳐서 main에 반영

  ```bash
    git merge --squash feature-branch
    git commit
  ```

- 장점

  - 히스토리 단순화: 불필요한 중간 커밋 없이, 깔끔한 히스토리 유지 가능.
  - 작은 커밋(디버깅, 테스트 커밋 등)을 정리 가능.

- 단점

  - 커밋 세부 내역 손실: 어떤 단계에서 어떤 작업이 이뤄졌는지 추적하기 어려움.
  - 같은 브랜치를 다시 사용할 때 충돌이 발생할 가능성 있음.

- 추천 상황
  - 작업 단위가 작은 단발성 브랜치
  - 빠른 배포 및 간단한 이력 관리가 필요한 스타트업/소규모 팀

### Rebase and Merge

- PR 브랜치의 커밋을 대상 브랜치 위로 재배치
- 동작 ex) main 브랜치에 병합할 때

  ```bash
    git rebase main
  ```

  - 결과: feature-branch의 커밋이 main 브랜치 히스토리에 순차적으로 연결됨.

- 장점

  - 히스토리 깔끔: 병합 커밋 없이 직선형 히스토리 유지.
  - 각 커밋 내역을 그대로 보존.

- 단점

  - 충돌 시 복잡성: 커밋 단위로 충돌을 해결해야 하므로 난이도가 높음.
  - 강제 푸시(force push) 필요 시 위험 요소 존재.

- 추천 상황
  - 히스토리를 깔끔하게 유지하고 싶은 팀
  - CI/CD 파이프라인이나 코드 리뷰에서 명확한 변경 추적이 중요한 환경

## 📓 TypeScript에서 Interface, Enum,Type의 차이점과 사용방법

### 개념과 차이점

| **구분**        | **interface**           | **type**                                  | **enum**                        |
| --------------- | ----------------------- | ----------------------------------------- | ------------------------------- |
| **설명**        | 객체의 구조를 정의      | 타입을 정의하고 조합·변형 가능            | 상수 집합을 정의                |
| **확장성**      | `extends`로 상속 가능   | 교집합(&), 합집합(\|) 등 유연한 조합 가능 | 값 기반, 런타임에서도 사용 가능 |
| **런타임 영향** | 컴파일 시 제거됨        | 컴파일 시 제거됨                          | **런타임에도 존재**             |
| **적합한 상황** | 객체·클래스의 구조 정의 | 유니온 타입, 복잡한 타입 조합             | 상수 값 그룹을 명확히 표현      |

### 사용예시

1. interface

```ts
interface User {
  id: number;
  name: string;
}

const user: User = { id: 1, name: 'John' };

interface Admin extends User {
  role: string;
}
```

2. type

```ts
type ID = number | string;

type User = {
  id: ID;
  name: string;
};

const user: User = { id: 'A101', name: 'Alice' };

type SuccessResponse = { status: 'success'; data: string };
type ErrorResponse = { status: 'error'; message: string };

type ApiResponse = SuccessResponse | ErrorResponse;
```

3. enum

```ts
enum Role {
  ADMIN = 'admin',
  USER = 'user',
  GUEST = 'guest',
}

function checkRole(role: Role) {
  if (role === Role.ADMIN) console.log('관리자 접근');
}

checkRole(Role.USER);
```

## 📓 React에서 JSX/TSX 컴포넌트의 Props 타입을 Interface로 지정하는 이유

- 확장성 : extends로 쉽게 다른 인터페이스를 상속할 수 있어, 컴포넌트 확장이나 재사용에 유리함.
- 선언 병합 지원 : 동일한 이름의 인터페이스를 여러 번 선언하면 자동으로 병합되어, 타입 확장이 용이함.
- 가독성 : 객체 구조를 직관적으로 표현할 수 있어 협업 시 이해하기 쉬움.
- 커뮤니티 컨벤션 : 많은 React/TypeScript 프로젝트에서 Props는 interface, 유틸리티 타입은 type으로 정의하는 것이 일반적인 스타일.

### 코드 예시

```ts
interface ButtonProps {
  label: string;
  onClick?: () => void;
}

const Button: React.FC<ButtonProps> = ({ label, onClick }) => {
  return <button onClick={onClick}>{label}</button>;
};

// 확장

interface IconButtonProps extends ButtonProps {
  icon: React.ReactNode;
}

const IconButton: React.FC<IconButtonProps> = ({ label, onClick, icon }) => {
  return (
    <button onClick={onClick}>
      {icon} {label}
    </button>
  );
};
```

## 📓 실행 컨텍스트

- JavaScript 코드가 실행되는 환경을 정의하고, 변수·함수·스코프·this 등의 정보를 담고 있는 논리적 컨테이너
- 코드가 실행될 때 어떤 변수를 참조할 수 있는지, 어떤 this가 바인딩되는지를 결정하는 핵심 개념

### 실행 컨텍스트의 종류

- 전역 실행 컨텍스트 (Global Execution Context)

  - 코드가 처음 실행될 때 생성됨
  - 전역 스코프를 형성하고, window(브라우저)나 global(Node.js) 객체가 this로 바인딩됨

- 함수 실행 컨텍스트 (Function Execution Context)

  - 함수가 호출될 때마다 새로 생성
  - 함수 내부의 변수, 매개변수, arguments 객체, this 등을 관리

- eval 실행 컨텍스트
  - eval() 함수 호출 시 생성됨

### 생성 및 실행 과정

- 생성 단계(Creation Phase)

  - 변수, 함수 선언, this 바인딩 등을 미리 설정
  - 이 과정에서 var 변수는 undefined로 호이스팅되고, let/const는 TDZ(Temporal Dead Zone)에 들어감

- 실행 단계(Execution Phase)
  - 코드가 한 줄씩 실행되며 변수에 값이 할당되고 로직이 처리됨

## 질문 다시 답변해보기

### ✔︎ Git과 Github

```text
Git은 로컬에서 코드를 버전 관리하는 도구이고, GitHub는 그 Git 저장소를 클라우드에서 호스팅하며 협업과 자동화를 지원하는 플랫폼입니다. 즉, Git이 버전 관리의 ‘엔진’이라면, GitHub는 협업을 위한 ‘서비스’라고 볼 수 있습니다.
```

### ✔︎ GitHub PR 병합 시, Merge Commit vs Squash Commit vs Rebase Commit

```text
“GitHub에서 PR 병합 시에는 Merge Commit, Squash Commit, Rebase Commit 세 가지 방식이 있습니다. Merge Commit은 기존 커밋을 유지하고 병합 커밋을 추가해 이력을 상세히 추적할 수 있지만, 로그가 복잡해집니다. Squash Commit은 여러 커밋을 하나로 합쳐 이력을 단순화할 수 있지만, 작업 과정이 사라집니다. Rebase Commit은 직선형 히스토리를 유지할 수 있지만, 충돌 해결이 번거롭습니다.
저는 소규모 프로젝트에서는 Squash로 이력을 간결하게 관리했고, 팀 프로젝트에서는 Merge Commit을 사용해 변경 과정을 명확히 추적할 수 있도록 했습니다.”
```

### ✔︎ TypeScript에서 Interface, Enum,Type의 차이점과

```text
TypeScript에서 interface, type, enum은 각각 용도가 다릅니다. interface는 객체나 클래스의 구조를 정의하고 확장성 있는 타입 설계에 적합합니다. type은 유니온 타입이나 복잡한 타입 조합을 정의할 때 유용합니다. enum은 런타임에도 남는 상수 집합을 정의할 때 사용합니다.
```

### ✔︎ React에서 JSX/TSX 컴포넌트의 Props 타입을 Interface로 지정하는 이유

```text
React 컴포넌트의 Props 타입을 정의할 때는 주로 interface를 사용합니다.
확장과 선언 병합이 가능해 재사용성이 높고, 협업 시 가독성도 좋기 때문입니다.
예를 들어 버튼 컴포넌트를 상속해 아이콘 버튼 같은 파생 컴포넌트를 만들 때도 유연하게 대응할 수 있어 실무에서도 표준처럼 활용되고 있습니다.
```

### ✔︎ 실행 컨텍스트

```text
실행 컨텍스트는 자바스크립트 코드가 실행되는 환경을 추상화한 개념으로, 어떤 변수를 참조할 수 있는지, 어떤 this가 바인딩되는지 등을 관리합니다. 코드가 실행되면 전역 컨텍스트가 먼저 생성되고, 함수 호출 시마다 새로운 함수 실행 컨텍스트가 생성되어 콜 스택에 쌓입니다. 이 구조 덕분에 스코프 체인과 호이스팅 같은 동작이 가능해집니다.
```
